{
  "version": 3,
  "sources": ["../../unplugin-vue-router/dist/chunk-P5ZSFRBZ.mjs", "../../unplugin-vue-router/dist/runtime.mjs"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => {\n  if (symbol = Symbol[name])\n    return symbol;\n  throw Error(\"Symbol.\" + name + \" is not defined\");\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __await = function(promise, isYieldStar) {\n  this[0] = promise;\n  this[1] = isYieldStar;\n};\nvar __yieldStar = (value) => {\n  var obj = value[__knownSymbol(\"asyncIterator\")];\n  var isAwait = false;\n  var method;\n  var it = {};\n  if (obj == null) {\n    obj = value[__knownSymbol(\"iterator\")]();\n    method = (k) => it[k] = (x) => obj[k](x);\n  } else {\n    obj = obj.call(value);\n    method = (k) => it[k] = (v) => {\n      if (isAwait) {\n        isAwait = false;\n        if (k === \"throw\")\n          throw v;\n        return v;\n      }\n      isAwait = true;\n      return {\n        done: false,\n        value: new __await(new Promise((resolve) => {\n          var x = obj[k](v);\n          if (!(x instanceof Object))\n            throw TypeError(\"Object expected\");\n          resolve(x);\n        }), 1)\n      };\n    };\n  }\n  return it[__knownSymbol(\"iterator\")] = () => it, method(\"next\"), \"throw\" in obj ? method(\"throw\") : it.throw = (x) => {\n    throw x;\n  }, \"return\" in obj && method(\"return\"), it;\n};\n\nexport {\n  __spreadValues,\n  __spreadProps,\n  __yieldStar\n};\n", "import {\n  __spreadProps,\n  __spreadValues\n} from \"./chunk-P5ZSFRBZ.mjs\";\n\n// src/data-fetching/defineLoader.ts\nimport {\n  useRouter,\n  useRoute\n} from \"vue-router\";\n\n// src/data-fetching/dataCache.ts\nimport { ref, effectScope } from \"vue\";\nfunction isCacheExpired(entry, options) {\n  const { cacheTime } = options;\n  return (\n    // cacheTime == 0 means no cache\n    !cacheTime || // did we hit the expiration time\n    Date.now() - entry.when >= cacheTime || Array.from(entry.children).some(\n      (childEntry) => isCacheExpired(childEntry, options)\n    )\n  );\n}\nfunction createDataLoaderEntry(options, initialData) {\n  return withinScope(() => ({\n    pending: ref(false),\n    error: ref(),\n    // set to 0 to when there is an initialData so the next request will always trigger the data loaders\n    when: initialData === void 0 ? Date.now() : 0,\n    children: /* @__PURE__ */ new Set(),\n    // @ts-expect-error: data always start as empty\n    data: ref(initialData),\n    params: {},\n    query: {},\n    // hash: null,\n    isReady: false\n    // this was just too annoying to type\n  }));\n}\nfunction updateDataLoaderEntry(entry, data, params, query, hash) {\n  entry.when = Date.now();\n  entry.params = params;\n  entry.query = query;\n  entry.hash = hash.v;\n  entry.isReady = true;\n  entry.data.value = data;\n}\nvar scope;\nfunction withinScope(fn) {\n  return (scope = scope || effectScope(true)).run(fn);\n}\nfunction stopScope() {\n  if (scope) {\n    scope.stop();\n    scope = void 0;\n  }\n}\nvar currentContext;\nfunction getCurrentContext() {\n  return currentContext || [];\n}\nfunction setCurrentContext(context) {\n  currentContext = context;\n}\n\n// src/data-fetching/locationUtils.ts\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n    if (typeof innerValue === \"string\") {\n      if (innerValue !== outerValue)\n        return false;\n    } else if (!innerValue || !outerValue) {\n      if (innerValue !== outerValue)\n        return false;\n    } else {\n      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))\n        return false;\n    }\n  }\n  return true;\n}\n\n// src/data-fetching/defineLoader.ts\nvar DEFAULT_DEFINE_LOADER_OPTIONS = {\n  cacheTime: 1e3 * 5,\n  // 5s\n  lazy: false,\n  // same as no key\n  key: \"\"\n};\nfunction defineLoader(nameOrLoader, _loaderOrOptions, opts) {\n  const loader = typeof nameOrLoader === \"function\" ? nameOrLoader : _loaderOrOptions;\n  opts = typeof _loaderOrOptions === \"object\" ? _loaderOrOptions : opts;\n  const options = __spreadValues(__spreadValues({}, DEFAULT_DEFINE_LOADER_OPTIONS), opts);\n  const entries = /* @__PURE__ */ new WeakMap();\n  let pendingPromise;\n  let currentNavigation;\n  const pendingLoad = () => pendingPromise;\n  const dataLoader = () => {\n    let [parentEntry, _router, _route] = getCurrentContext();\n    const router = _router || useRouter();\n    const route = _route || useRoute();\n    if (\n      // no cache: we need to load\n      !entries.has(router) || // invoked by the parent, we should try to load again\n      parentEntry\n    ) {\n      load(route, router, parentEntry);\n    }\n    const entry = entries.get(router);\n    const promise = Promise.resolve(pendingPromise).then(() => dataLoaderResult).finally(() => {\n      if (parentEntry) {\n        parentEntry.children.add(entry);\n      }\n      setCurrentContext(parentEntry && [parentEntry, router, route]);\n    });\n    const { data, pending, error } = entry;\n    function refresh() {\n      invalidate();\n      load(route, router, parentEntry);\n      return pendingPromise.catch(() => {\n      });\n    }\n    function invalidate() {\n      entry.when = 0;\n    }\n    const dataLoaderResult = {\n      data,\n      pending,\n      error,\n      refresh,\n      invalidate,\n      pendingLoad\n    };\n    return Object.assign(promise, dataLoaderResult);\n  };\n  function load(route, router, parent, initialRootData) {\n    const hasCacheEntry = entries.has(router);\n    const initialData = initialRootData && initialRootData[options.key];\n    if (!hasCacheEntry) {\n      entries.set(router, createDataLoaderEntry(options, initialData));\n    }\n    const entry = entries.get(router);\n    if (initialData) {\n      entry.when = 0;\n      return Promise.resolve();\n    }\n    const needsNewLoad = !hasCacheEntry || shouldFetchAgain(entry, route);\n    const { isReady, pending, error } = entry;\n    const { lazy } = options;\n    const isExpired = isCacheExpired(entry, options);\n    if (pendingPromise && // if we need to fetch again due to param/query changes\n    !needsNewLoad && // if it's a new navigation and there is no entry, we cannot rely on the pendingPromise as we don't know what\n    // params and query were used and could have changed. If we had an entry, then we can rely on the result of\n    // `needsNewLoad`\n    currentNavigation === route && // if we are not ready but we have a pendingPromise, we are already fetching so we can reuse it\n    (!isReady || !isExpired)) {\n      return lazy ? Promise.resolve() : pendingPromise;\n    }\n    if (needsNewLoad || // if we never finished loading we cannot rely on needsNewLoad\n    !isReady && currentNavigation !== route || // we did a load but the cache expired\n    isReady && isExpired) {\n      pending.value = true;\n      error.value = null;\n      currentNavigation = route;\n      const [trackedRoute, params, query, hash] = trackRoute(route);\n      if (!pendingPromise) {\n        setCurrentContext([entry, router, route]);\n      }\n      const thisPromise = pendingPromise = loader(trackedRoute).then((data) => {\n        if (pendingPromise === thisPromise) {\n          updateDataLoaderEntry(entry, data, params, query, hash);\n        }\n      }).catch((err) => {\n        error.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        if (pendingPromise === thisPromise) {\n          pendingPromise = null;\n          pending.value = false;\n        }\n        setCurrentContext(parent && [parent, router, route]);\n      });\n    }\n    return lazy || // lazy resolves immediately to not block navigation guards\n    !pendingPromise ? Promise.resolve() : (\n      // pendingPromise is thisPromise\n      pendingPromise\n    );\n  }\n  dataLoader._ = {\n    // loader,\n    entries,\n    load,\n    options\n  };\n  dataLoader[IsLoader] = true;\n  return dataLoader;\n}\nfunction shouldFetchAgain(entry, route) {\n  return (\n    // manually invalidated\n    !entry.when || !includesParams(route.params, entry.params) || !includesParams(route.query, entry.query) || entry.hash != null && entry.hash !== route.hash || Array.from(entry.children).some(\n      (childEntry) => shouldFetchAgain(childEntry, route)\n    )\n  );\n}\nvar IsLoader = Symbol();\nfunction isDataLoader(loader) {\n  return loader && loader[IsLoader];\n}\nfunction trackRoute(route) {\n  const [params, paramReads] = trackObjectReads(route.params);\n  const [query, queryReads] = trackObjectReads(route.query);\n  let hash = { v: null };\n  return [\n    __spreadProps(__spreadValues({}, route), {\n      // track the hash\n      get hash() {\n        return hash.v = route.hash;\n      },\n      params,\n      query\n    }),\n    paramReads,\n    queryReads,\n    hash\n  ];\n}\nfunction trackObjectReads(obj) {\n  const reads = {};\n  return [\n    new Proxy(obj, {\n      get(target, p, receiver) {\n        const value = Reflect.get(target, p, receiver);\n        reads[p] = value;\n        return value;\n      }\n    }),\n    reads\n  ];\n}\n\n// src/data-fetching/dataFetchingGuard.ts\nvar HasDataLoaderMeta = Symbol();\nvar ADDED_SYMBOL = Symbol();\nfunction setupDataFetchingGuard(router, { initialData } = {}) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (ADDED_SYMBOL in router) {\n      console.warn(\n        \"[vue-router]: Data fetching guard added twice. Make sure to remove the extra call.\"\n      );\n      return;\n    }\n    router[ADDED_SYMBOL] = true;\n  }\n  const fetchedState = {};\n  let isFetched;\n  router.beforeEach((to) => {\n    return Promise.all(\n      // retrieve all loaders as a flat array\n      to.matched.flatMap((route) => route.meta[HasDataLoaderMeta]).filter(Boolean).map(\n        (moduleImport) => moduleImport().then((mod) => {\n          const loaders = Object.keys(mod).filter((exportName) => isDataLoader(mod[exportName])).map((loaderName) => mod[loaderName]);\n          return Promise.all(\n            // load will ensure only one request is happening at a time\n            loaders.map((loader) => {\n              const {\n                options: { key },\n                entries\n              } = loader._;\n              return loader._.load(\n                to,\n                router,\n                void 0,\n                initialData\n                // FIXME: could the data.value be passed as an argument here?\n              ).then(() => {\n                if (!initialData) {\n                  if (key) {\n                    fetchedState[key] = entries.get(router).data.value;\n                  }\n                } else if (process.env.NODE_ENV !== \"production\" && !key && !isFetched) {\n                }\n              });\n            })\n          );\n        })\n      )\n    ).then(() => {\n      initialData = void 0;\n      isFetched = true;\n    });\n  });\n  return initialData ? null : fetchedState;\n}\n\n// src/runtime.ts\nvar _definePage = (route) => route;\nfunction _mergeRouteRecord(main, ...routeRecords) {\n  return routeRecords.reduce((acc, routeRecord) => {\n    const meta = Object.assign({}, acc.meta, routeRecord.meta);\n    const alias = [].concat(\n      acc.alias || [],\n      routeRecord.alias || []\n    );\n    Object.assign(acc, routeRecord);\n    acc.meta = meta;\n    acc.alias = alias;\n    return acc;\n  }, main);\n}\nexport {\n  HasDataLoaderMeta as _HasDataLoaderMeta,\n  defineLoader as _defineLoader,\n  _definePage,\n  _mergeRouteRecord,\n  setupDataFetchingGuard as _setupDataFetchingGuard,\n  stopScope as _stopDataFetchingScope\n};\n"],
  "mappings": "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",
  "names": []
}
